###### WETUBE JS SUMMARY ######

< Settings >

1. #### Node JS ####
== 브라우저 바깥에서 쓸 수 있는 자바스크립트

2. #### NPM ####
== 자바스크립트 언어를 위한 패키지 매니저
== Node JS와 상호작용을 할 수 있게 해줌
== 

3. #### Express - NPM ####
== npm i(=install) express -> node_modules파일 + package-lock.json 파일 생성     
                           -> 기존 package.json파일 dependencies express 생성됨
                           -> npm i 실행 시 dependencies에 해당되는 모듈들을 다 설치해줌
                           -> .gitignore -> /node_modules -> 다른사람들에게 node_modules 파일을 보내지 않아도 됨. package.json파일만 있어도 됨
                           -> dependencies에 express 있을 시 이후 npm i 만 실행해도 됨
                           -> package-lock.json -> 패키지들을 안전하게 관리함

== npm init -> 새 npm패키지 또는 기존 npm 패키지를 설정 할 수 있음 
            -> package.json 만드는 걸 도와줌
== node_modules -> npm으로 설치한 모든 패키지가 저장됨

4. #### Package.json ####
== json -> 그냥 텍스트 파일임. 파일에 정보를 저장하기 위해 만든 방식 중 하나
== npm 활용 -> npm init을 통해 package.json 생성
== node.js 관련 정보를 담는 방법으로 일반적인 Text이므로 무엇을 넣어도 상관없음

== script 엔트리를 생성하고 그 안에 script를 입력하면 --> npm run (script이름) 을 사용할 수 있음
(ex)ppopopp
"scripts": {
    "win": "node index.js" --> npm run win 실행 시 index.js파일 실행됨
}

"scripts": {
    "dev" : "nodemon -- exec babel-node src/server.js" --> npm run dev 사용 가능
}

5. #### Babeljs.io - JS compiler ####
== https://babeljs.io/setup#installation 참조
== 작성한 최신 자바스크립트를 nodeJS가 이해할 수 있는 자바스크립트로 바꿔주는 것
== dependencies: 프로젝트가 작동하기 위해 필요한 것들
== devDependencies: 개발자가 개발할 때 필요한 것들 
(ex) -- nodemon, babel-node
1. nodemon(파일을 보고 있다가 변화가 있으면 commend를 재시작 시켜줌) 서버를 만드는 데 필수적인 요소는 아니지만 개발환경을 편하게 해줌
2. nodemon -> babel-node를 실행 -> src 폴더에 가서 server.js 실행


NodeJS에서 필요한 babel설치
npm install --save-dev @babel/core
npm install @babel/preset-env --save-dev

babel.config.json파일 생성
```
{
"presets": ["@babel/preset-env"]
}
```

@babel/preset-env
@babel/preset-env는 환경에 필요한 구문 변환을 세부적으로 관리할 필요 없이 최신 JavaScript를 사용할 수 있게 해주는 preset

6. #### Nodemon ####
== https://babeljs.io/setup#installation 참조
== 실행방법
    1. npm install @babel/core @babel/node --save-dev
    2. npm i nodemon --save-dev

== node index.js(nodeJS로 실행) -> babel-node index.js(최신 문법 코드로 실행) -> nodemon --exec babel-node index.js(babel-node를 실행하는 nodemon)
== ex) "scripts": { nodemon --exec babel-node index.js" }
== 만든 파일이 수정되는 걸 감시해주는 패키지 -> 파일이 수정되면 알아서 재시작해줌 
                                          -> npm run 을 계속 실행해주지 않아도 됨

-----------------------------------------------------------------------------------------------------------------------------------------------

< Server >

1. #### Server ####
== 항상 켜져있고 인터넷에 연결 돼 있으면서 request를 listening하고 있는 컴퓨터 
== 브라우저는 서버에게 홈페이지를 요구하고, 브라우저가 요청한 걸 서버는 응답해줘야 함 --> 응답이 없을 시 무한 로딩
(ex)
import express from "express" == const 
const app = express();
app.get("/", handleHome) -> get(route, handler) ----> 서버에게 홈페이지를 request 후 handler 응답

2. #### GET Requests ####
== 브라우저는 대신해서  웹사이트를 요청하고, 페이지를 가져다 줌 == 페이지를 가져와 !!
== (ex) import express from "express";
        const app = express();

        => app.get("root", callback)
        app.get("/", () => console.log("Somebody is trying to go home.")) => 누군가가 root page로 get request를 보낸다면 함수를 실행

        const handleHome = () => console.log("Somebody is trying to go home.") => 위와 동일
        app.get("/", handleHome))

        app.get("/", console.log("Somebody is trying to go home.")) => 무조건 함수로 실행해야 하므로 오류
== request => 사용자가 원하는 것을 요청하는 것 
           => but, 사용자가 직접 get request를 하는 것이 아니라 브라우저가 get request를 보내는 것
           => get request에는 어디로 가려는지 /home, /login과 같은 route가 있음.

3. #### ( Request, Responses ) ####
== request를 받으면 브라우저가 request를 보내고 root 페이지를 가져달라는 request를 받으면 응답 !!
==  express.js에서 method 확인
    (ex) const handleHome = (req, res) => {
            return res.end(); -> 접속 종료
            return res.send("Hello"); -> 메세지 보냄
        };
 
4. #### Middleware ####
== 말 그대로 중간에 있는 software - request와 response의 중간 
== 모든 함수는 request 오브젝트와, response 오브젝트 말고도 next 파라미터를 가지고 있음 (req,res,next) / 하지만 그 중 함수가 next()를 호출 시 Middleware이 됨
== next 파라미터는 다음으로 request 를 처리할 콜백함수를 담고있음 
== 원하는 만큼 사용가능하며 누군가가 응답하기 전까지 request와 관련된 모든 controller는 모두 Middleware이다
== app.use => 모든 router들에서 사용 => app.get 전에 사용되어야 함

5. #### Morgan ####
== npm i morgan
== NodeJS를 위한 HTTP request logger
== npm i morgan
https://www.npmjs.com/package/morgan

== Morgan사용법
https://www.npmjs.com/package/morgan#examples

skip을 사용해서 특정 statusCode만 필터 가능
```
// EXAMPLE: only log error responses
morgan('combined', {
skip: function (req, res) { return res.statusCode < 400 }
})
```

6. #### Router && Controllers ####

모든 Express 애플리케이션에는 앱 라우터가 내장되어 있음.
라우터는 미들웨어 자체처럼 작동하므로 app.use()에 대한 인수로 또는 다른 라우터의 use() 메서드에 대한 인수로 사용 가능
최상위 익스프레스 객체에는 새로운 라우터 객체를 생성하는 Router() 메서드가 있다.

https://expressjs.com/ko/4x/api.html#router

(ex)
const videoRouter = express.Router();
const handleWatchVideo = (req,res) => res.send("Watch Video");
videoRouter.get("/watch",handleWatchVideo);

app.use("/videos", videoRouter); 
-> 누군가가 "/videos"로 시작하는 url에 접근하면
-> express는 videoRouter로 들어가고
-> videoRouter는 가지고 있는 url로 들어감으로써 handleWatchVideo 실행

-> Router와 Controller를 같이 쓰는 건 권장하지 않음
-> 따로 작성한 뒤 export && import 실행
-> export default는 내보내는 게 1개 밖에 없기에 변수명을 바꿔줘도 되지만
    export는 내보내는 게 여러가지라 선언된 변수명 그대로 써줘야 함

7. #### Export && Import ####
== 프로젝트에 있는 모든 파일은 분리된 모습이므로
== 무언가를 바깥에 공유하기 위해서는 export를 먼저 해줘야 함

====> Default Export 
== default export일 경우 이름을 동일하게 설정하지 않아도 됨 하지만 파일 당 하나만 설정할 수 있음
(ex)```
export default globalRouter;

=> 둘 다 가능
import globalRouter from "./routers/globalRouter";
import global from "./routers/globalRouter";
```

====> Export
== 하나의 파일에 export 여러개일 경우에는 const 앞에 export 사용 하지만 이름을 동일하게 설정해야 함
     export const trending = (req, res) => res.send("Home Page Videos");
     export const watch = (req, res) => res.send("Watch");
     export const edit = (req, res) => res.send("Edit");

     import { trending } from "../controllers/videoController";


8. #### URL Parameters ####

/:id => url에 변수값을 넣어 줄 수 있게 해준다
id - 변수명
: - /:id id가 변수라고 인식하게 해줌
(ex)
videoRouter.get("/:변수명/edit", edit);
-> URL 안에 변수를 넣어줌
-> req.params.변수명

== Routing
https://expressjs.com/ko/guide/routing.html

== 정규표현식 테스트 사이트
https://www.regexpal.com

== \w+: 모든 문자, 숫자 선택
== \d+: 모든 숫자 선택


-----------------------------------------------------------------------------------------------------------------------------------------------

< PUG == Returning HTML  >


1. #### PUG ####

== PUG 사용 이유
    1. 깔끔한 HTML 사용 가능
    2. HTML에 자바스크립트를 포함시킬 수 있음
    3. 반복하지 않아도 한 파일로 모든 템플릿을 업데이트 할 수 있음

== PUG 사용법
    1. PUG 설치 => npm i pug
    2. 뷰 엔진을 pug로 설정 => app.set("view enging", "pug");
    3. pug 파일 생성
    => pug파일 생성시 유의점 => 파일명은 모두 소문자로, 띄어쓰기 X

== 참조 https://www.npmjs.com/package/pug

== Express와 함께 템플리트 엔진을 사용
== Express가 템플리트를 렌더링하려면 다음과 같은 애플리케이션 설정이 필요
    views, 템플리트가 있는 디렉토리 (ex) app.set('views', './views')
    view engine, 사용할 템플리트 엔진 (ex) app.set('view engine', 'pug')

== 참조 https://expressjs.com/ko/guide/using-template-engines.html

Application Settings (Express어플리케이션 설정)
https://expressjs.com/ko/4x/api.html#app.us

2. #### PUG - PARTIALS ####

== 중복되는 코드를 효율적으로 관리할 수 있게 만듦
== 별도의 유니크한 파일 생성 후 include 파일 위치 (ex) include partials/footer.pug

3. #### PUG - Block && Extends ####

== https://pugjs.org/language/inheritance.html
== extends 확장 , inheritance 상속
(ex) base.pug를 만들어서
extend base.pug 로 해당 템플릿에서 원하는 부분만 바꿀 수 있게 함
base.pug에 block 이라는 공간을 집어넣어서
block 을 base.pug가 아닌 다른 템플릿에서 바꿔줌


4. #### Rendering ####

== pug를 렌더링해주는건 controller!
== render는 2개의 argument를 받는다
== 하나는 view, 다른 하나는 템플릿에 보낼 변수! (ex) controller => export const trending = (req, res) => res.render("home", { pageTitle: "Home", potato: "Jehyeon" });
					       		title #{pageTitle} | Wetube #{potato}

== 템플릿에 변수를 생성하는법 #{}

5. #### Conditionals - 조건 ####

참조 https://pugjs.org/language/conditionals.html

6. #### Iteration - 반복 ####

== Pug는 each와 while라는 두 가지 기본 반복 방법을 지원
```
ul
each val in [1, 2, 3, 4, 5]
	li= val
```

== 배열이나 객체에 반복할 값이 없으면 실행될 else 블록을 추가할 수도 있습니다.
```
- var values = [];
ul
	each val in values
		li= val
	else
		li There are no values
```
참조 https://pugjs.org/language/iteration.html


7. #### Mixins ####

mixin은 partial이긴 하지만 데이터를 받을 수 있는 partial

-controller-
const videos = [
{
title: "First Video",
rating: 5,
comments: 2,
createdAt: "2 minutes ago",
views: 62,
id: 1,
}
]

-mixin-
mixin video(info)
div
h4=info.title
ul
li #{info.rating}/5.
li #{info.comments}/comments.
li Posted #{info.created}.
li #{info.views} views.

-pug-
include mixins/video

each info in videos
+video(info)


-----------------------------------------------------------------------------------------------------------------------------------------------

< Fake Database >


1. #### POST ####
array database와 HTML 상호작용 과정
1. 각 비디오에 id 부여
2. id를 기반으로 비디오마다 anchor 생성
3. 임의의 id를 가진 url에 접근하려고 할 때, 해당 id를 가져와서 변수에 저장
4. 저장된 id를 기반으로 해당 id 에 해당하는 object를 변수에 저장
5. 저장된 object를 기반으로 HTML 렌더링하여 contents 출력

2. #### Absolute && Relative URL ####
== 제일앞에 /가있으면 절대경로
(ex)
a(href="/video/edit")--->localhost:4000/video/edit
a(href="video/edit")--->localhost:4000/videos/video/edit
a(href=`${video.id}/edit`)--->localhost:4000/videos/1/edit

3. #### GET request && POST request ####
== GET => form을 화면에 보여줌 
== POST => 변경사항을 저장

> Get은 서버에서 어떤 데이터를 가져와서 보여줄때 사용합니다. 어떤 값이나 내용, 상태등을 바꾸지 않는 경우에 사용을 하는 것
> Post는 서버상의 데이터 값이나 상태를 바꾸기 위해서 사용

4. #### req.body ####
== req.body를 사용함으로써 유저가 input에 작성한 data를 얻을 수 있음
== 생성한 input에 이름을 생성하지 않을 경우 적용되지 않음 
req.body에는 form을 통해 submit된 데이터의 키-값 쌍을 포함합니다.
기본적으로는 undefined이며 express.json() 또는 express.urlencoded()와 같은 바디 파싱 미들웨어를 사용할 때 값을 받아옵니다.

```
// 애플리케이션/json 파싱
app.use(express.json());
// application/x-www-form-urlencoded파싱 (form데이터 파싱)
app.use(express.urlencoded({ extended: true }));
==> HTML 형식을 이해하고 우리가 이해할 수 있는 JavaScript Object 형식으로 통역해줌
```
https://expressjs.com/ko/api.html#req.body

express.urlencoded([options])
Express에 내장된 미들웨어 기능입니다. urlencoded 페이로드로 들어오는 요청을 구문 분석하고 바디 파서를 기반으로 합니다.
https://expressjs.com/ko/api.html#express.urlencoded


-----------------------------------------------------------------------------------------------------------------------------------------------

< REAL DATABASE - Mongo DB >

#### 1. CRUD ####

#### 2. Schema && Model ####

== Mongoose의 모든 것은 스키마로 부터 시작된다
== 각 스키마는 MongoDB 컬렉션에 매핑되고 해당 컬렉션 내 문서의 모양을 정의한다
== Models => 스키마 정의에서 컴파일된 생성자로 모델은 기본 MongoDB 데이터 베이스에서 문서를 만들고 읽는다.
== DB를 mongoose와 연결시켜서 Video model을 인식시킨다

(ex)
```
const videoSchema = new mongoose.Schema({
    title: String,
    description: String,
    createdAt: Date,
    hashtags: [{type: String}],
    meta: {
        views: Number,
        rating: Number,
    },
});

const Video = mongoose.model("Video", videoSchema(데이터의 형태));
```
== 참조
== https://mongoosejs.com/docs/guide.html#schemas
== https://mongoosejs.com/docs/guide.html#models
== https://mongoosejs.com/docs/models.html


#### 3. Query ####

#### 4. Async Await ####

== async(비동기) -- await(수행될 때까지 기다려준다)
=> 데이터베이스가 데이터 찾을때까지 기다려준다(다음 것이 먼저 수행되는 것을 막음)
에러는 try-catch문으로 잡는다. 
== callback function 의 장점은 에러들을 바로 볼 수 있다는것
== await는 database에게 결과값을 받을때까지 js가 기다리게 해줄 수 있음
== async await의 장점은 매우 직관적이고 js가 어디서 어떻게 기다리는지 알 수 있다
== awiat는 function이 async 상태일 경우에 안에서 사용 가능하며 callback function과 달리 promise방식은 error가 어디서 오는지 명확하지 않음
== 명확하지 않으므로 try catch 방법을 사용 => 말 그대로 try 안에 있는 코드를 사용

< Callback function >
```
video.find({}, (error, videos) => {
	if(error){
		return res.render("server-error")
	}
	return res.render("home")
});
```


< Promise >
```
export const home = async (req, res) => {
	try {
		const videos = await video.find({});
		return res.render("home", { pageTitle: "Home", videos });
	} catch {
		return res.render("server-error");
	}
};
```

#### 5. Return && Render ####

== return의 역할 : 본질적인 return의 역할보다는 function을 마무리짓는 역할로 사용되고 있음.
==> 이러한 경우 return이 없어도 정상적으로 동작하지만 실수를 방지하기 위해 return을 사용
== render한 것은 다시 render할 수 없음
==> redirect(), sendStatus(), end() 등등 포함 (express에서 오류 발생)

#### 6. Mongoose - Schema ####

== Mongoose Schema는 Mongoose Model을 구성하기 위한 객체로 생각할 수 있음
== Mongoose의 모든 것은 Schema로 시작하며, 각 스키마는 MongoDB 컬렉션에 매핑되고 해당 컬렉션 내 문서의 모양을 정의한다
== https://mongoosejs.com/docs/schematypes.html
== https://mongoosejs.com/docs/guide.html

#### 7. 정규표현식 #### 

http://regexpal.com

== MongoDB는 ObjectID를 24바이트 16진 문자열 표현으로 반환
== https://mongodb.github.io/node-mongodb-native/api-bson-generated/objectid.html
== https://docs.mongodb.com/manual/reference/method/ObjectId/ 

== 십육진법 (Hexadecimal)
== 십육진법은 십육을 밑으로 하는 기수법이다. 보통 0부터 9까지의 수와 A에서 F까지의 로마 문자를 사용하고, 이때 대소문자는 구별하지 않는다.
== Hexadecimal: 0~9까지의 숫자와 A-F까지의 알파벳이 조합된 string

== findOne
해당 조건과 일치하는 document를 찾는다.
_id로 찾는 경우에는 findById()를 사용할 것을 권장
findById(id)는 거의* findOne({ _id: id })과 동일합니다.
https://mongoosejs.com/docs/api.html#model_Model.findOne

findById
https://mongoosejs.com/docs/api.html#model_Model.findById

#### 8. Grammar ####
== video.hashtags = hashtags.split(",").map((word) => word.startsWith('#') ? word : `#${word}`);
== 해쉬태그를 컴마 기준으로 나눈 후 단어가 #으로 시작하면 word 아니면 #word로 출력
== String.prototype.startsWith()
== startsWith() 메소드는 어떤 문자열이 특정 문자로 시작하는지 확인하여 결과를 true 혹은 false로 반환
== https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

== String.prototype.endsWith()
== The endsWith() 메서드를 사용하여 어떤 문자열에서 특정 문자열로 끝나는지를 확인할 수 있으며, 그 결과를 true 혹은 false로 반환
== https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

== Model.findByIdAndUpdate() 한번에 찾고 업데이트까지
== new Model & Model.save() -> Model.create({})이랑 비슷!

== Model.exists로 video object전체가 아닌 조건 유무를 true,false로 판단해서 검색함
== Model.exists({조건문 ex) _id : id , title : title})

== findByIdAndDelete()
== document의 _id 필드로 MongoDB findOneAndDelete() 명령 실행
== findByIdAndDelete(id)는 findOneAndDelete({ _id: id })의 줄임말
== https://mongoosejs.com/docs/api.html#model_Model.findByIdAndDelete

#### 9. Use Mongo ####

1. Mongo 사용하기
> mongo // mongosh

2. 내가 가진 db 보기
> show dbs

3. 현재 사용 중인 db 확인
> db

4. 사용할 db 선택하기
> use dbName => use wetubedb

5. db 컬렉션 보기
> show collections

6. db 컬렉션 안에 documents 보기
> db.collectionName.find() => db.videos.find()

7. db 컬렉션 안에 documents 내용 모두 제거하기 
> db.collectionName.remove({}) => db.videos.remove({})
> db.videos.remove({})가 deprecated됐다고 뜬다면 db.videos.deleteMany({})로 전체 비디오 삭제


#### 10. Middleware ####

== Middleware(pre또는 post훅이라고도 불림)는 비동기 함수를 실행하는 동안 제어가 전달되는 함수
== Mongoose는 document middleware, model middleware, aggregate middleware, query middleware 4가지 미들웨어가 존재
== https://mongoosejs.com/docs/middleware.html#middleware

== model middleware가 지원하는 기능
== document middleware함수에서 this는 현재 document를 참조합니다. https://mongoosejs.com/docs/middleware.html#types-of-middleware
== https://mongoosejs.com/docs/middleware.html#pre


#### 11. Statics ####

모델에 static 함수를 추가할 수도 있습니다.
스키마에서 컴파일된 모델에 정적 "class" 메서드를 추가합니다.

Static 사용하는 두 가지 방법
```
// Assign a function to the "statics" object of our animalSchema
animalSchema.statics.findByName = function(name) {
return this.find({ name: new RegExp(name, 'i') });
};
// Or, equivalently, you can call `animalSchema.static()`.
animalSchema.static('findByBreed', function(breed) { return this.find({ breed }); });
```
https://mongoosejs.com/docs/guide.html#statics

#### 12. Requests ####

== 라우터로 지정한 :id -> req.params
== pug파일에서 input으로 받은 내용 -> req.body(form이 POST일 때)
== pug파일에서 input으로 받은 url내용 -> req.query (form이 GET일 때)


#### 13. Regular Expression - 정규표현식 ####

== https://www.regexpal.com
== (ex)  title = { $regex: new RegExp(keyword, "i") } => regular expression 안에 title에 keyword가 포함하는 것을 찾기 
== "i" => 대문자, 소문자 구분하지 않음
== `^${keyword}` => 제목이 keyword로 시작하는 것을 찾기
== `${keyword}$` => 제목이 keyword로 끝나는 것을 찾기

몽고DB regex ($regex)
몽고DB에서 정규표현식을 사용하기 위해 사용하는 키워드
쿼리의 패턴 일치 문자열에 대한 정규식 기능을 제공합니다.
https://docs.mongodb.com/manual/reference/operator/query/regex

RegExp mdn
RegExp 생성자는 패턴을 사용해 텍스트를 판별할 때 사용합니다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp

RegExp 사용 방법
RegExp 객체는 리터럴 표기법과 생성자로써 생성할 수 있습니다.
리터럴 표기법의 매개변수는 두 빗금으로 감싸야 하며 따옴표를 사용하지 않습니다.
생성자 함수의 매개변수는 빗금으로 감싸지 않으나 따옴표를 사용합니다.
```
/ab+c/i 를 아래 RegExp 생성자를 이용해서 만들 수 있습니다.
new RegExp(/ab+c/, 'i') // 리터럴 표기법
new RegExp('ab+c', 'i') // 생성자 함수
```


-----------------------------------------------------------------------------------------------------------------------------------------------


< User Authentication >

#### 1. Hashing ####

== npm i bcrypt

(ex)
userSchema.pre("save", async function () {
  console.log("Password: ", this.password);
  this.password = await bcrypt.hash(this.password, 5);
  console.log("Hashing Password: ", this.password);
});

==> userSchema.pre("save", async function() {} => 말그대로 pre save 저장하기 전에 잠깐 가로채서 작업할 수 있게 만듦
==> 여기서 this는 create되는 User을 가리킴

해시함수. 5분 설명 영상
https://www.youtube.com/watch?v=67UwxR3ts2E

remove() 명령어 실행이 안될 때
db.users.remove()는 deprecated되었기 때문에
db.users.deleteMany({})로 지우시면 됩니다.

해시함수 테스트
https://emn178.github.io/online-tools/sha256.html

bcrypt 설치
암호를 해시하는 데 도움이 되는 라이브러리입니다.
npm i bcrypt
https://www.npmjs.com/package/bcrypt

Schema.prototype.pre()
https://mongoosejs.com/docs/api.html#schema_Schema-pre


#### 2. Status Codes - 상태코드 ####

== 200(OK): 서버가 요청을 제대로 처리했다는 뜻이다. 이는 주로 서버가 요청한 페이지를 제공했다는 의미로 쓰인다.
== 400(Bad Request): 서버가 요청의 구문을 인식하지 못할 때 발생한다. 클라이언트 측에서 문제가 있을 때 주로 발생한다.
== 404(Not Found): 서버가 요청한 페이지를 찾을 수 없을 때 발생한다. 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 제공한다.
== https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C

== res.status(code) => response에 대한 HTTP 상태를 설정합니다. (status를 설정한다.)
== https://expressjs.com/ko/api.html#res.status
== https://nodejs.org/api/http.html#http_response_statuscode

#### 3. Compare Password ####

== bcrypt를 이용해서 비밀번호 비교

 > password: 유저가 입력한 비밀번호 // user.passwordHash: DB에 해시화되서 저장된 비밀번호 

```
  const match = await bcrypt.compare(password, user.passwordHash);
```

> 비밀번호 변경 시 현재 비밀번호와 DB에 저장된 비밀번호가 맞지 않을 시 보내는 오류메세지 예시
```
  const ok = await bcrypt.compare(oldPassword, password);
  if(!ok) {
    return res.status(400).render("users/change-password", {
      pageTitle: "Change Password",
      errorMessage: "The current password is incorrect",
    });
  }
```
== https://www.npmjs.com/package/bcrypt

#### 4. Session ####

== express-session(Express용 세션 미들웨어)
== 세션 데이터는 쿠키 자체에 저장되지 않고 세션 ID에만 저장되며 세션 데이터는 서버 측에 저장됨
== npm i express-session
== https://www.npmjs.com/package/express-session

== Session 
=> 백엔드와 브라우저 간에 어떤 활동을 했는지 기억하는 것 (브라우저와 백엔드 사이에 기억-역사 같은 느낌?) 
=> 이러한 점들이 작용하기 위해선 백엔드와 브라우저가 서로에 대한 정보를 지니고 있어야함
=> 유저가 로그인할 때 유저에게 어떠한 텍스트를 줌
=> 브라우저 접속시 백엔드가 요청을 보내는 사용자에게 id를 보내고 있음 => 세션
=> 브라우저가 요청을 보낼 때마다 같이 id를 보내줘서 브라우저와 일치하는 세션이 뭔지 알 수 있고
=> 세션 id를 가지고 있으면 세션 object에 정보를 추가할 수 있음


#### 5. 백엔드와 브라우저 소통방식 ####

== 백엔드와 브라우저는 동일하게 세션 ID를 저장하며 브라우저는 쿠키라는 저장소에 세션 아이디를 저장하고 다닌다
== 브라우저가 백엔드에게 요청할 때는 쿠키를 보내고 백엔드에서 세션 ID의 유무를 확인한 후 응답해준다

=> 결론은 세션 id가 쿠키 안에 저장되고, 백엔드에도 저장됨
=> 백엔드는 생성된 모든 세션 id를 관리하는 곳 == 사용자가 4명이면 세션 저장소에는 4개의 세션이 있는 것
=> 브라우저에서 서버에 로그인 요청을 해서 로그인이 되면 서버는 세션 id를 응답해주고
=> 브라우저는 쿠키스토리지에 세션id를 보관하고 있다가 다시 서버에 방문할 시에는 세션 id만 보여주면 자동으로 로그인되게 해줘서 계속 로그인할 수고를 덜어줌
=> locals object는 이미 모든 템플릿에 import된 개체

(ex)
```
app.use(
    session({
        secret: "Hello",
        resave: false,
        saveUninitialized: falase,
        cookie: {
            maxAge: 20000
        },
    })
);
```

> 로그인 하는 방법
req.session을 통해 session(object로 이루어져있음)에 접근 가능
loggedIn = true , user = user(앞서 변수로 선언한) 를 넣어줌으로 res.local으로 접근해서 가져올 수가 있음




#### 6. MongoStore ####

== connect-mongo > https://www.npmjs.com/package/connect-mongo
== express-session > https://www.npmjs.com/package/express-session
== 쿠키에는 세션 데이터가 아닌 세션 ID에만 저장된다. 세션 데이터는 서버에 저장되지만 기본 서버 측 세션 저장소인 MemoryStore는 production 환경용으로 설계되지 않았음


#### 7. Resave && Uninitialized Sessions ####

* resave : 모든 request마다 세션의 변경사항이 있든 없든 세션을 다시 저장
- true:
+ 스토어에서 세션 만료일자를 업데이트 해주는 기능이 따로 없으면 true로 설정하여 매 request마다 세션을 업데이트 해주게 함
- false:
+ 변경사항이 없음에도 세션을 저장하면 비효율적이므로 동작 효율을 높이기 위해 사용
+ 각각 다른 변경사항을 요구하는 두 가지 request를 동시에 처리할때 세션을 저장하는 과정에서 충돌이 발생할 수 있는데 이를 방지하기위해 사용


* saveUninitialized : uninitialized 상태인 세션을 저장한다. 여기서 uninitialized 상태인 세션이란 request 때 생성된 이후로 아무런 작업이 가해지지않는 초기상태의 세션
- true:
+ 클라이언트들이 서버에 방문한 총 횟수를 알고자 할때 사용
- false:
+ uninitialized 상태인 세션을 강제로 저장하면 내용도 없는 빈 세션이 스토리지에 계속 쌓일수 있다. 이를 방지, 저장공간을 아끼기 위해 사용


#### 8. Expiration and Secrets ####

== Cookie
== > Secret > 세션 ID 쿠키에 서명하는 데 사용되는 비밀 > 백엔드가 쿠키를 줬다는 걸 보여주기 위함
== > Domain > 쿠키를 만든 백엔드가 누구인지 알려줌
== > Expires > HTTP 타임스템프로 기록된 쿠키의 최대 생존 시간(수명)
== > Max-age > 말그대로 쿠키가 만료될 때 까지의 시간 (밀리세컨드)


#### 9. Dotenv ####

== npm i dotenv > 
== require("doetenv").config()
process.env.(환경변수) 읽어보자!
1. npm i dotenv
2. 가능한 한 가장 먼저 사용하기 require("dotenv").config()
2-1)사용할 모든 파일에 require("dotenv").config() 붙이기
2-2)require("dotenv").config() -> import "dotenv/config" 변환 후 init.js에 넣어주기
(why init.js? -> dev를 실행하면 init.js가 제일 먼저 실행되기 때문)


#### 10. ENV ####
== .env 파일은 관습적으로 모두 대문자 사용
== 사용 방법
1. .env 파일 생성
2. .env 파일을 깃허브에 올라가는 걸 방지하기 위해 .gitignore 파일에 .env 파일 추가 
3. 비밀로 해야하는 string을 process.env.(환경변수)로 바꾸기 


#### 11. Github Login > Authorizing OAuth Apps ####

== 다른 사용자가 OAuth 앱을 승인하도록 할 수 있다
== GitHub의 OAuth 구현은 웹 브라우저에 대한 액세스 권한이 없는 앱에 대한 표준 인증 코드 부여 유형 및 OAuth 2.0 장치 인증 부여를 지원함

== https://github.com/settings/developers
1. 사용자를 깃허브로 보낸다 > https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps
2. URL에 있는 것들을 바꿈으로써 다양한 방법으로 사용자를 승인할 수 있음 (ex) allow-signup, scope ...


== Web application flow
웹 애플리케이션 흐름: 브라우저에서 실행되는 표준 OAuth 앱에 대해 사용자에게 권한을 부여하는 데 사용

== 앱 사용자에게 권한을 부여하는 웹 애플리케이션 흐름
1. 로그인하려는 사이트에서 유저의 GitHub identity를 request하기 위해 유저를 GitHub 페이지로 리다이렉트시킵니다.
2. 유저는 리다이렉트된 GitHub에서 승인을 하고, GitHub에 의해 다시 로그인하려는 사이트로 리다이렉트됩니다.
3. 로그인 하려는 사이트는 유저의 액세스 토큰을 통해 API에 접근 > https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps

== 깃허브 OAuth Apps Setting > GitHub API를 사용하기 위해 등록한 애플리케이션 > https://github.com/settings/developers

== Scopes for OAuth Apps (OAuth 앱의 범위) > https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps

== Creating an OAuth App (OAuth앱 만들기) > https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app


== scope > 유저에게서 얼마나 많은 정보를 읽어내고 어떤 정보를 가져올 것에 대한 것 > https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps



#### 12. Scopes for OAuth Apps ####

OAuth 앱은 초기 리디렉션에서 범위를 요청할 수 있습니다. %20을 사용하여 공백으로 구분하여 여러 범위를 지정할 수 있습니다.
// 사용 예시
```
https://github.com/login/oauth/authorize?client_id=...&scope=user%20repo_deployment
```
https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps

URLSearchParams
URLSearchParams 인터페이스는 URL의 쿼리 문자열에 대해 작업할 수 있는 유틸리티 메서드를 정의합니다.
https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams

URLSearchParams.toString()
toString() 은 URLSearchParams 인터페이스의 메소드로서, URL에서 사용할 수 있는 쿼리 문자열을 리턴합니다.
https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams/toString



~7.20 복습 필요

Github REST API (User)
사용자 API를 사용하면 인증된 사용자에 대한 공개 및 비공개 정보를 얻을 수 있습니다.
https://docs.github.com/en/rest/reference/users

Get the authenticated user
인증된 사용자가 기본 인증 또는 사용자 범위의 OAuth를 통해 인증되면 응답에 공개 및 비공개 프로필 정보가 나열됩니다. 인증된 사용자가 사용자 범위 없이 OAuth를 통해 인증된 경우 응답에는 공개 프로필 정보만 나열됩니다.

Add an email address for the authenticated user
https://docs.github.com/en/rest/reference/users#add-an-email-address-for-the-authenticated-user

List public email addresses for the authenticated user
인증된 사용자의 공개 이메일 주소 나열
https://docs.github.com/en/rest/reference/users#list-public-email-addresses-for-the-authenticated-user
#### 13. Fetch ####

== npm install node-fetch 




#### 카카오 로그인 ####

카카오 로그인 구현하기 (REST API)

카카오 로그인 구현 > 아래 링크 참조
구현 방식은 깃허브 로그인과 거의 동일
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api

0. 애플리케이션 등록
https://developers.kakao.com/docs/latest/ko/getting-started/app

1. 인가 코드 받기
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#request-code

2. 토큰 받기
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#request-token

3. 사용자 정보 가져오기
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#req-user-info


















Express Session
== 쿠키에는 세션 데이터가 아닌 세션 ID에만 저장됨
== 세션 데이터는 서버 측에 저장
== 하지만 기본 서버 측 세션 저장소인 MemoryStore는 production 환경용으로 설계되지 않았습니다.
== https://www.npmjs.com/package/express-session

Compatible Session Stores (호환가능한 세션 스토어)
https://www.npmjs.com/package/express-session#compatible-session-stores

connect-mongo
Typescript로 작성된 Connect 및 Express용 MongoDB 세션 저장소.
npm i connect-mongo
https://www.npmjs.com/package/connect-mongo


#### Uninitialized Sessions ####
* resave : 모든 request마다 세션의 변경사항이 있든 없든 세션을 다시 저장한다.
- true:
+ 스토어에서 세션 만료일자를 업데이트 해주는 기능이 따로 없으면 true로 설정하여 매 request마다 세션을 업데이트 해주게 한다.
- false:
+ 변경사항이 없음에도 세션을 저장하면 비효율적이므로 동작 효율을 높이기 위해 사용한다.
+ 각각 다른 변경사항을 요구하는 두 가지 request를 동시에 처리할때 세션을 저장하는 과정에서 충돌이 발생할 수 있는데 이를 방지하기위해 사용한다.


* saveUninitialized : uninitialized 상태인 세션을 저장한다. 여기서 uninitialized 상태인 세션이란 request 때 생성된 이후로 아무런 작업이 가해지지않는 초기상태의 세션을 말한다.
- true:
+ 클라이언트들이 서버에 방문한 총 횟수를 알고자 할때 사용한다.
- false:
+ uninitialized 상태인 세션을 강제로 저장하면 내용도 없는 빈 세션이 스토리지에 계속 쌓일수 있다. 이를 방지, 저장공간을 아끼기 위해 사용한다.












#### Github Login ####
Authorizing OAuth Apps
다른 사용자가 OAuth 앱을 승인하도록 할 수 있습니다.
GitHub의 OAuth 구현은 웹 브라우저에 대한 액세스 권한이 없는 앱에 대한 표준 인증 코드 부여 유형 및 OAuth 2.0 장치 인증 부여를 지원합니다.

Web application flow
웹 애플리케이션 흐름: 브라우저에서 실행되는 표준 OAuth 앱에 대해 사용자에게 권한을 부여하는 데 사용됩니다.
앱 사용자에게 권한을 부여하는 웹 애플리케이션 흐름은 다음과 같습니다.
1. 로그인하려는 사이트에서 유저의 GitHub identity를 request하기 위해 유저를 GitHub 페이지로 리다이렉트시킵니다.
2. 유저는 리다이렉트된 GitHub에서 승인을 하고, GitHub에 의해 다시 로그인하려는 사이트로 리다이렉트됩니다.
3. 로그인 하려는 사이트는 유저의 액세스 토큰을 통해 API에 접근합니다.
https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps

깃허브 OAuth Apps Setting
GitHub API를 사용하기 위해 등록한 애플리케이션입니다.
https://github.com/settings/developers

Scopes for OAuth Apps (OAuth 앱의 범위)
https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps

Creating an OAuth App (OAuth앱 만들기)
https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app

Scopes for OAuth Apps
OAuth 앱은 초기 리디렉션에서 범위를 요청할 수 있습니다. %20을 사용하여 공백으로 구분하여 여러 범위를 지정할 수 있습니다.
// 사용 예시
```
https://github.com/login/oauth/authorize?client_id=...&scope=user%20repo_deployment
```
https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps

URLSearchParams
URLSearchParams 인터페이스는 URL의 쿼리 문자열에 대해 작업할 수 있는 유틸리티 메서드를 정의합니다.
https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams

URLSearchParams.toString()
toString() 은 URLSearchParams 인터페이스의 메소드로서, URL에서 사용할 수 있는 쿼리 문자열을 리턴합니다.
https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams/toString

https://github.com/login/oauth/access_token

####



-----------------------------------------------------------------------------------------------------------------------------------------------

< User Profile >



#### 1. Edit ####

Model.findByIdAndUpdate()

문서의 _id 필드로 mongodb findAndModify 업데이트 명령을 실행합니다. findByIdAndUpdate(id, ...)는 findOneAndUpdate({ _id: id }, ...)와 동일합니다.

```
// 사용 예시
Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options, callback)

// is sent as (+타입스크립트)
Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options, callback)
```
https://mongoosejs.com/docs/api.html#model_Model.findByIdAndUpdate



#### 2. 비밀번호 비교 ####

bcrypt
// 비밀번호 비교
const match = await bcrypt.compare(password, user.passwordHash);
https://www.npmjs.com/package/bcrypt

Model.findByIdAndUpdate()
findByIdAndUpdate로는 pre('save')를 실행시키지 않기 때문에 비밀번호가 해시화되지 않고 DB에 저장되게 된다. 그래서 save()메서드를 통해 pre('save')를 실행시켜 비밀번호를 해시화한 후 DB에 저장될 수 있도록 해준다.
https://mongoosejs.com/docs/api.html#model_Model.findByIdAndUpdate

Model.prototype.save()
findByIdAndUpdate를 이용해서 Document업데이트 후 save하기
앞서 했던 것처럼 findByIdAndUpdate를 통해 Document를 업데이트 시키고 업데이트된 최신 Document를 받아서 save를 할 수도 있습니다.
(자바스크립트로 진행하신다면 $set은 사용하지 않으셔도 됩니다.)
```
const updatedUser = await User.findByIdAndUpdate(loggedInUser?._id, { $set: { password: newPassword } }, { new: true });
await updatedUser?.save();
```
https://mongoosejs.com/docs/api.html#model_Model-save

DB 삭제방법
Mongo에 가서 db.sessions.remove({}) -> db.users.remove({})


#### 3. Multer - 파일 업로드 ####

> Multer

== npm i multer
== 주로 파일 업로드에 사용되는 multipart/form-data를 처리하기 위한 node.js 미들웨어
== Multer는 multipart(multipart/form-data)가 아닌 form을 처리하지 않음
== https://www.npmjs.com/package/multer 

== DB에는 파일을 저장하는 것이 아닌 파일의 위치만 저장 !!!


> Multer 사용법

multer(opts)
dest 또는 storage: 파일을 저장할 위치
fileFilter: 허용되는 파일을 제어하는 ​​함수
limits: 업로드된 데이터의 한계
preservePath: 기본 이름 대신 파일의 전체 경로 유지

사용 예시
```
  const multer = require('multer')
  const upload = multer({ dest: './public/data/uploads/' })
  app.post('/stats', upload.single('uploaded_file'), function (req, res) {
  // req.file is the name of your file in the form above, here 'uploaded_file'
  // req.body will hold the text fields, if there were any
  console.log(req.file, req.body)
});
```

.single(fieldname)
이름이 fieldname인 단일 파일을 수락하며 단일 파일은 req.file에 저장됨

express.static(root, [options])

Express에 내장된 미들웨어 기능입니다. 정적 파일을 제공하며 serve-static을 기반으로 합니다. root 인수는 static asset을 제공할 root 디렉토리를 지정합니다. 이 함수는 req.url을 제공된 root 디렉토리와 결합하여 제공할 파일을 결정합니다.

https://expressjs.com/ko/api.html#express.static




#### 4. Upload Video ####

샘플 비디오 파일 사이트
https://sample-videos.com/
https://sample-videos.com/video123/mp4/720/big_buck_bunny_720p_1mb.mp4

multer limit
fileSize: multipart forms의 경우 최대 파일 크기 (바이트)
https://www.npmjs.com/package/multer

Byte to MB
1000000 Bytes(백만 Bytes) = 1 MB (in decimal)
1000000 Bytes = 0.95367431640625 MB (in binary)
https://www.gbmb.org/bytes-to-mb


#### 5. Object Id ####

ObjectId
ObjectId는 일반적으로 고유 식별자에 사용되는 특수 유형입니다. ObjectId는 클래스이고 ObjectId는 객체입니다. 그러나 종종 문자열로 표시됩니다. toString()을 사용하여 ObjectId를 문자열로 변환하면 24자의 16진수 문자열을 얻습니다.
_someId: Schema.Types.ObjectId,
https://mongoosejs.com/docs/schematypes.html#objectids

Mongoose Typescript ObjectIds및 다른 타입 설정
https://mongoosejs.com/docs/typescript.html#objectids-and-other-mongoose-types

#### 6. Populate ####

Mongoose에는 populate()를 통해 다른 컬렉션의 문서를 참조할 수 있습니다. Population은 문서의 지정된 경로를 다른 컬렉션의 문서로 자동 교체하는 프로세스입니다. 단일 문서, 여러 문서, 일반 개체, 여러 일반 개체 또는 쿼리에서 반환된 모든 개체를 채울 수 있습니다.
const story = await Story.findOne({ title: 'Casino Royale' }).populate('author');
https://mongoosejs.com/docs/populate.html

Population
https://mongoosejs.com/docs/populate.html#population

#### 7. Modified ####
혹시 isModified()가 항상 false를 리턴하는 문제가 있으시거나 또는 isModified()외에 또 다른 방법을 찾으시는 분은 findByIdAndUpdate나 findOneAndUpdate를 사용하시면 됩니다.
(findByIdAndUpdate나 findOneAndUpdate는 Document를 업데이트할 때, pre save()훅을 실행시키지 않습니다.)
https://stackoverflow.com/questions/50581825/ismodified-and-pre-save-mongoose-nodejs

Document.prototype.isModified()
주어진 경로 중 하나라도 수정되면 true를 반환하고, 그렇지 않으면 false를 반환합니다. 인수가 없으면 이 문서의 경로가 수정되면 true를 반환합니다. 경로가 제공되면 경로 또는 경로 체인의 일부로 경로를 포함하는 전체 경로가 수정되었는지 확인합니다.
```
doc.isModified() // true
doc.isModified('documents') // true
```
https://mongoosejs.com/docs/api.html#document_Document-isModified

403 Forbidden
HTTP 403 Forbidden 클라이언트 오류 상태 응답 코드는 서버에 요청이 전달되었지만, 권한 때문에 거절되었다는 것을 의미합니다.
이 상태는 401과 비슷하지만, 로그인 로직(틀린 비밀번호로 로그인 행위)처럼 반응하여 재인증(re-authenticating)을 하더라도 지속적으로 접속을 거절합니다.
https://developer.mozilla.org/ko/docs/Web/HTTP/Status/403



-----------------------------------------------------------------------------------------------------------------------------------------------

< Webpack >

#### 1. Install Webpack ####

Webpack은 .jpg 같은 거는 압축된 jpg 를 주고, JS 는 못생긴 거로, Sass 는 몬생긴 css 로 준다. 압축, 변형, 최소화등 필요한 작업들을 거치고 정리된 코드를 결과물로 준다.

webpack, webpack-cli devDependencies 로 설치

webpack아 여기는 소스파일들이 있고 여기는 너가 결과물을 보낼 폴더야
webpack.config.js 파일에서 webpack 환경설정. 이 파일에서는 되게 몬생긴 JS 만 쓸 수 있다.

중요한 거 두 가지(필수 설정)

- entry: 우리가 처리하고자 하는 파일들(예쁜 js)
- entry: 이 프로퍼티에 우리가 처리하고자 하는 파일의 경로 입력
- output: 결과물
- filename: 이 프로퍼티에 우리 결과물이 될 파일 이름 입력
- path: 이 프로퍼티에 우리 결과물 파일을 어디에 저장할 지 지정 (이 경로는 절대경로여야 해!)

#### 2. SCSS ####

== Sass Loader > scss파일을 가져다가 css파일로 전환시켜줌

sass, sass-loader, css-loader, style-loader 설치
npm i sass sass-loader css-loader style-loader -D

sass-loader
Sass/SCSS 파일을 로드하고 CSS로 컴파일합니다.
https://webpack.js.org/loaders/sass-loader/

SCSS
Variable
Sass 변수는 간단합니다. $로 시작하는 이름에 값을 할당하면 값 자체 대신 해당 이름을 참조할 수 있습니다.
```
$base-color: #c6538c;
$border-dark: rgba($base-color, 0.88);

.alert {
border: 1px solid $border-dark;
}
```
https://sass-lang.com/documentation/variables

@import
@import CSS at-rule은 다른 스타일 시트에서 스타일 규칙을 가져오는 데 사용됩니다.
https://developer.mozilla.org/en-US/docs/Web/CSS/@import
https://sass-lang.com/documentation/at-rules/import#plain-css-imports


#### 3. MiniCssExtractPlugin ####


이 플러그인은 CSS를 별도의 파일로 추출합니다. CSS가 포함된 JS 파일별로 CSS 파일을 생성합니다. mini-css-extract-plugin을 css-loader와 결합하는 것이 좋습니다.
npm install --save-dev mini-css-extract-plugin
https://webpack.kr/plugins/mini-css-extract-plugin/

MiniCssExtractPlugin Options
```
plugins: [new MiniCssExtractPlugin({ filename: "css/style.css" })]
```
https://webpack.js.org/plugins/mini-css-extract-plugin/#publicpath

CssMinimizerWebpackPlugin
https://webpack.kr/plugins/css-minimizer-webpack-plugin/

#### 4. CSS ####

Reset CSS
https://meyerweb.com/eric/tools/css/reset

FontAwesome CDN
https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css